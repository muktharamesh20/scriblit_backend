---
timestamp: 'Tue Nov 04 2025 01:47:06 GMT-0500 (Eastern Standard Time)'
content_id: a6417dff747be28c136db0fdd2bbd4d83afab226cac6a42a7380be3f4fefd5f8
---

# file: src/syncs/scriblink.sync.ts

```typescript
/**
 * Synchronizations for Scriblink concepts
 * Coordinates actions between authentication, folders, notes, tags, and summaries
 */

import { Folder, Notes, PasswordAuth, Requesting, Summaries } from "@concepts";
import { actions, Frames, Sync } from "@engine";
import { ID } from "@utils/types.ts";

/********************************** System Syncs **********************************/

/**
 * When a user is registered, automatically create their root folder
 */
export const CreateRootFolderOnRegistration: Sync = (
  { user },
) => ({
  when: actions(
    [PasswordAuth.register, {}, { user }],
  ),
  then: actions([
    Folder.initializeFolder,
    { user },
  ]),
});

/**
 * When a note is deleted, remove it from any folder it's in
 */
export const RemoveNoteFromFolderOnDeletion: Sync = ({ noteId, user }) => ({
  when: actions([
    Notes.deleteNote,
    { noteId, user },
    {},
  ]),
  then: actions([
    Folder.deleteItem,
    { item: noteId },
  ]),
});

/**
 * When a note is deleted, also delete its summary
 */
export const DeleteSummaryOnNoteDeletion: Sync = ({ noteId, user }) => ({
  when: actions([
    Notes.deleteNote,
    { noteId, user },
    {},
  ]),
  then: actions([
    Summaries.deleteSummary,
    { item: noteId },
  ]),
});

export const InitializeNewlyCreatedNote: Sync = (
  {
    user,
    content,
    folder,
    title,
    note,
  },
) => ({
  when: actions(
    [Notes.createNote, { user, title, folder, content }, { note }],
  ),
  then: actions(
    [Folder.insertItem, { item: note, folder }],
    [Notes.updateContent, { user, note, newContent: content }],
  ),
});

export const deleteChildNotes: Sync = ({
  user,
  folder,
  note,
  deletedItems,
  owner,
}) => ({
  when: actions([
    Folder.deleteFolder,
    { f: folder },
    { deletedItems, owner },
  ]),
  where: (frames) => {
    const result = new Frames();
    for (const frame of frames) {
      const items = frame[deletedItems] as ID[];
      const folderOwner = frame[owner] as ID;

      // Filter out error cases (handled by error sync)
      if (!Array.isArray(items)) {
        continue;
      }

      // Expand each item/note into a separate frame with the owner
      for (const itemId of items) {
        result.push({
          ...frame,
          [note]: itemId,
          [user]: folderOwner,
        });
      }
    }
    return result;
  },
  then: actions([
    Notes.deleteNote,
    { noteId: note, user },
  ]),
});

/********************************** User Requests **********************************/

export const DeleteFolderRequest: Sync = ({
  request,
  user,
  folderId,
  authToken,
  authenticatedUser,
}) => ({
  when: actions([
    Requesting.request,
    {
      path: "/Folder/deleteFolder",
      user,
      folderId,
      authToken,
    },
    { request },
  ]),
  where: async (frames) => {
    return await authenticateRequest(
      frames,
      authToken,
      user,
      authenticatedUser,
    );
  },
  then: actions([Folder.deleteFolder, { f: folderId }]),
});

export const CreateNoteRequest: Sync = ({
  request,
  user,
  content,
  folder,
  title,
  authToken,
  authenticatedUser,
}) => ({
  when: actions([
    Requesting.request,
    {
      path: "/Notes/createNote",
      user,
      content,
      folder,
      title,
      authToken,
    },
    { request },
  ]),
  where: async (frames) => {
    return await authenticateRequest(
      frames,
      authToken,
      user,
      authenticatedUser,
    );
  },
  then: actions([Notes.createNote, { user, title, folder, content }]),
});

export const CreateFolderRequest: Sync = ({
  request,
  user,
  title,
  parent,
  authToken,
  authenticatedUser,
}) => ({
  when: actions([
    Requesting.request,
    {
      path: "/Folder/createFolder",
      user,
      title,
      parent,
      authToken,
    },
    { request },
  ]),
  where: async (frames) => {
    return await authenticateRequest(
      frames,
      authToken,
      user,
      authenticatedUser,
    );
  },
  then: actions([Folder.createFolder, { user, title, parent }]),
});

export const MoveFolderRequest: Sync = ({
  request,
  user,
  folderId,
  newParentId,
  authToken,
  authenticatedUser,
}) => ({
  when: actions([
    Requesting.request,
    {
      path: "/Folder/moveFolder",
      user,
      folderId,
      newParentId,
      authToken,
    },
    { request },
  ]),
  where: async (frames) => {
    return await authenticateRequest(
      frames,
      authToken,
      user,
      authenticatedUser,
    );
  },
  then: actions([Folder.moveFolder, { folderId, newParentId, userId: user }]),
});

export const DeleteNoteRequest: Sync = ({
  request,
  user,
  noteId,
  authToken,
  authenticatedUser,
}) => ({
  when: actions([Requesting.request, {
    path: "/Notes/deleteNote",
    user,
    noteId,
    authToken,
  }, { request }]),
  where: async (frames) => {
    return await authenticateRequest(
      frames,
      authToken,
      user,
      authenticatedUser,
    );
  },
  then: actions([Notes.deleteNote, { noteId, user }]),
});
/********************************* User Responses *********************************/

export const DeleteFolderResponse: Sync = ({
  request,
  folderId,
  user,
  accessToken,
  deletedFolders,
  deletedItems,
}) => ({
  when: actions(
    [Requesting.request, { path: "/Folder/deleteFolder", user, folderId }, {
      request,
    }],
    [Folder.deleteFolder, { f: folderId }, { deletedFolders, deletedItems }],
  ),
  where: async (frames) => {
    // Folder.deleteFolder now returns { deletedFolders, deletedItems, owner } on success
    // or { error: string } on failure
    // Error cases are handled by DeleteFolderResponseError which matches on { error }
    // Success cases will have deletedFolders and deletedItems arrays
    return await generateTokenForResponse(frames, user, accessToken);
  },
  then: actions([Requesting.respond, { request, success: true, accessToken }]),
});

export const CreateNoteResponse: Sync = ({
  request,
  note,
  user,
  accessToken,
}) => ({
  when: actions(
    [Requesting.request, { path: "/Notes/createNote", user }, { request }],
    [Notes.createNote, {}, { note }],
  ),
  where: async (frames) => {
    return await generateTokenForResponse(frames, user, accessToken);
  },
  then: actions([Requesting.respond, { request, note, accessToken }]),
});

export const CreateFolderResponse: Sync = ({
  request,
  folder,
  user,
  accessToken,
}) => ({
  when: actions(
    [Requesting.request, { path: "/Folder/createFolder", user }, { request }],
    [Folder.createFolder, {}, { folder }],
  ),
  where: async (frames) => {
    return await generateTokenForResponse(frames, user, accessToken);
  },
  then: actions([Requesting.respond, { request, folder, accessToken }]),
});

export const MoveFolderResponse: Sync = ({
  request,
  success,
  user,
  accessToken,
}) => ({
  when: actions(
    [Requesting.request, { path: "/Folder/moveFolder", user }, { request }],
    [Folder.moveFolder, {}, { success }],
  ),
  where: async (frames) => {
    return await generateTokenForResponse(frames, user, accessToken);
  },
  then: actions([Requesting.respond, { request, success, accessToken }]),
});

export const DeleteNoteResponse: Sync = ({
  request,
  user,
  accessToken,
}) => ({
  when: actions(
    [Requesting.request, { path: "/Notes/deleteNote", user }, { request }],
    [Notes.deleteNote, {}, {}],
  ),
  where: async (frames) => {
    // Notes.deleteNote returns {} on success or { error: string } on failure
    // Empty output pattern {} means we don't try to match any output fields
    // Error cases are handled by DeleteNoteResponseError which matches on { error }
    return await generateTokenForResponse(frames, user, accessToken);
  },
  then: actions([Requesting.respond, { request, success: true, accessToken }]),
});

/********************************* User Errors **********************************/

export const CreateNoteResponseError: Sync = ({ request, error }) => ({
  when: actions(
    [Requesting.request, { path: "/Notes/createNote" }, { request }],
    [Notes.createNote, {}, { error }],
  ),
  then: actions([Requesting.respond, { request, error }]),
});

export const CreateFolderResponseError: Sync = ({ request, error }) => ({
  when: actions(
    [Requesting.request, { path: "/Folder/createFolder" }, { request }],
    [Folder.createFolder, {}, { error }],
  ),
  then: actions([Requesting.respond, { request, error }]),
});

export const MoveFolderResponseError: Sync = ({ request, error }) => ({
  when: actions(
    [Requesting.request, { path: "/Folder/moveFolder" }, { request }],
    [Folder.moveFolder, {}, { error }],
  ),
  then: actions([Requesting.respond, { request, error }]),
});

export const DeleteFolderResponseError: Sync = ({ request, error }) => ({
  when: actions(
    [Requesting.request, { path: "/Folder/deleteFolder" }, { request }],
    [Folder.deleteFolder, {}, { error }],
  ),
  then: actions([Requesting.respond, { request, error }]),
});

export const DeleteNoteResponseError: Sync = ({ request, error }) => ({
  when: actions(
    [Requesting.request, { path: "/Notes/deleteNote" }, { request }],
    [Notes.deleteNote, {}, { error }],
  ),
  then: actions([Requesting.respond, { request, error }]),
});

/**********************************System Errors **********************************/

/*********************************Helper Functions **********************************/

/**
 * Reusable authentication where clause for authenticated requests
 * Verifies token and ensures authenticated user matches requested user
 */
const authenticateRequest = async (
  frames: Frames,
  authToken: symbol,
  user: symbol,
  authenticatedUser: symbol,
): Promise<Frames> => {
  // Verify the auth token and get the authenticated user
  // The query returns { user: ... }, so we map it to authenticatedUser
  frames = await frames.query(
    PasswordAuth._getUserFromToken,
    { authToken },
    { user: authenticatedUser },
  );

  // If query returned empty (invalid token), return empty frames
  // This prevents the sync from firing, allowing auth error sync to handle it
  if (frames.length === 0) {
    return new Frames();
  }

  // Filter to ensure the authenticated user matches the user specified in the request
  const matchingFrames = frames.filter(($) => {
    const authUser = $[authenticatedUser];
    const reqUser = $[user];
    return authUser === reqUser;
  });

  return matchingFrames;
};

/**
 * Reusable token generation where clause for response syncs
 */
const generateTokenForResponse = async (
  frames: Frames,
  user: symbol,
  accessToken: symbol,
): Promise<Frames> => {
  // Generate a new access token for the user
  frames = await frames.query(
    PasswordAuth._generateNewAccessToken,
    { user },
    { accessToken },
  );
  return frames;
};

```
