# Reflection
## New Skills
I really enjoyed my experience with the project.  I felt like I learned a lot of important concepts.  For instance, I spent some time looking up JWT tokens and SHA after our lecture and Context recommended SHA.  It was really interesting how refresh tokens and access tokens worked, and I got practice with it by trying to implement a version of JWT myself with this project.

I also learned other skills like being able to prototype quickly and using your own computer to test out a website design before deploying it.  Learning how the console logs show up in the browser was also interesting since I didn’t realize we could do that.  One skill that I still need to work on is using mongoDB.  Using an LLM poses an interesting question about whether you should or not.  I came to this class to learn about full stack, but using an LLM meant that I didn’t actually write a lot of the code that went into websites.  Maybe that’s okay, but that does mean I’m still shaky on some concepts because I didn’t take the time to learn them fully.  However, I definitely still need to get better with databases and frontend code (like with Vue).

## Insights For Future Projects
I didn’t feel like the project was hard, per say, but it was time consuming.  Part of that was because I made some mistakes in the middle.  For instance, I remembered that the Requesting Concept was a thing from lecture, and decided to try implementing one for assignment 4a.  However, that just took up extra time, and undoing it all in assignment 4c made the project take upward of 60 hours for assignment 4c.  It was also hard to remember and find different methods in RequestAPI for the frontend in 4b because of this.  Modularity is important, and I should have realized this and just not implemented RequestAPI until we did the syncs in 4c.  In the future, I just always have to keep modularity in mind.

## LLM Reflection
I used Context to come up with code to implement concepts.  It was cool because you could decide exactly what context to give the tool.  However, ultimately I preferred Cursor because it will automatically test if its code is correct and fits in with the rest of the project.  Cursor is interesting because you do need the right model (or else it will make up information, or just really frustrate you by clearly making the problem worse) and you need to know how to prompt it.  I also liked using ChatGPT when I didn’t have Cursor.  I think I really got better with using agentic tools during this class.  I recognized things like how Grok was pretty good with debugging and about how the first few prompts should just tell the LLM to read what you think is important to debug the problem.  Also, the more specific you can be, the better.  Also, definitely use one chat for similar things.  For instance, I’d work through how to debug a sync with an LLM once or twice, and then it could do it on its own if I stayed in the same chat.  There was a lot I learned about agentic coding and quick prototyping with this project, and I really liked that.

